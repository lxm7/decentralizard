name: Push to main | Zero-Downtime Deployment
on:
  push:
    branches: [main]
jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      # Clone the repo
      - name: Checkout
        uses: actions/checkout@v4
      - name: Prepare SSH key
        run: |
          echo "${{ secrets.VPS_SSH_DEPLOY }}" | base64 -d > vps_key.pem
          chmod 0600 vps_key.pem
      - name: Prepare the known_hosts
        run: |
          mkdir ~/.ssh/ && touch ~/.ssh/known_hosts
          echo "${{ secrets.VPS_SSH_HOST_KEYS }}" | base64 -d >> ~/.ssh/known_hosts
      - name: Start the deployment of the latest version in the background
        run: |
          DATE=$(date "+%Y%m%d%H%M%S")

          ssh -i vps_key.pem [...] bash -c "'
          set -eo pipefail
          trap 'echo "Error on line $LINENO"; exit 1' ERR

          cd decentralizard
          git fetch origin
          git reset --hard origin/main

          # Build new image with version tag
          VERSION=$(date +%s)
          docker compose -f docker-compose.production.yml build --build-arg VERSION=$VERSION app

          # Start new container
          docker compose -f docker-compose.production.yml up -d \
            --no-deps \
            --scale app=2 \
            --label version=$VERSION

          # Wait for new container healthcheck
          NEW_CONTAINER_ID=$(docker ps -q --latest --filter "label=version=$VERSION")
          timeout 60 bash -c "while ! docker exec $NEW_CONTAINER_ID curl -fs http://localhost:3000/api/health; do sleep 2; done"

          # Stop old containers
          OLD_CONTAINERS=$(docker ps -q --filter "label=version!=$VERSION" --filter "name=app")
          [ -z "$OLD_CONTAINERS" ] || docker stop $OLD_CONTAINERS

          # Cleanup old images (keep last 2)
          docker image prune --force --all --filter "until=24h"
          docker image ls --format "{{.ID}} {{.CreatedSince}}" | grep "hours ago" | tail -n +3 | awk '{print $1}' | xargs docker rmi || true
